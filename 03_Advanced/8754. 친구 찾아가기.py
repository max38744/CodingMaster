'''
개구리 F가 사는 마을은 가로 길이와 세로 길이가 모두 N인 N × N 크기의 격자판 모양입니다.
격자판의 위에서부터 x번째, 왼쪽에서부터 y번째 칸을 (x, y)로 표현합니다.
격자판의 각 칸마다 높이가 있습니다. (x, y)의 높이는 H(x, y)로 표현합니다.

개구리 F는 자신의 집이 위치한 (1, 1)에서 출발해 친구의 집이 위치한 (N, N)으로 가려고 합니다.

개구리 F가 현재 위치한 칸 (a, b)에서 (c, d)로 이동하려면 다음 조건을 모두 만족해야 합니다. 단, a, b, c, d는 모두 1 이상 N 이하의 양의 정수입니다.
조건 1. |a - c| + |b - d| = 1
조건 2. H(a, b) ≥ H(c, d)

예를 들어 개구리 F가 현재 위치한 칸이 (2, 3)이라고 가정하겠습니다.
이 경우 개구리 F는 (1, 3), (2, 2), (2, 4), (3, 3) 중 (2, 3) 보다 높이가 낮은 칸으로 이동할 수 있습니다.

개구리 F는 조건 2를 최대 한 번 무시할 수 있습니다.
즉, (1, 1)에서 출발해 (N, N)에 도착할 때까지 최대 한 번 높이가 낮은 칸에서 높이가 높은 칸으로 이동할 수 있습니다.

개구리 F가 사는 마을의 높이 정보가 주어질 때, (1, 1)과 (N, N)을 포함해 개구리 F가 거쳐야 하는 칸의 최소 개수를 구하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫째 줄에 격자판의 가로, 세로 길이를 의미하는 양의 정수 N이 주어집니다. (2 ≤ N ≤ 100)
이어서 N개의 줄에 걸쳐 마을의 높이 정보가 주어집니다.
각 줄에는 N개의 양의 정수가 공백으로 구분되어 주어집니다.
각 칸의 높이는 1 이상 100 이하의 양의 정수입니다.』

[출력값 설명]
『첫째 줄에 개구리 F가 거쳐야 하는 칸의 최소 개수를 출력합니다.
단, 개구리 F가 (N, N)에 도착할 수 없는 경우 -1을 출력합니다.』
------------------------------------------------------------------------
예제 입력1
5
1 1 1 9 9
9 9 1 9 9
1 1 1 9 9
1 9 9 9 9
1 1 1 1 1

예제 출력1
9

예제 입력2
2
1 5
5 9

예제 출력2
-1
'''
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline
from collections import deque

if __name__ == "__main__":
    N = int(input())
    H = [list(map(int, input().split())) for _ in range(N)]
    direct = ((-1, 0), (1, 0), (0, -1), (0, 1)) # 상하좌우
    limit = 1 # 개구리가 높이 뛸 수 있는 1번의 기회
    answer = -1 # 정답 저장(bfs로 하면 도착하는 순간이 최소 개수)
    count = 1 # 이동한 칸 수 저장(자기 집도 포함인듯?)
    visited = [[False] * N for _ in range(N)] # 방문칸은 방문하지 마라~

    Q = deque()
    Q.append((0,0, limit, count, visited)) # 자기 집 (1,1)이 인덱스로는 (0,0)이다.
    while Q:
        x, y, l, c, v = Q.popleft()
        # 친구집 도착하면 이동 칸수 저장 하고 반복문 탈출
        if (x, y) == (N-1, N-1):
            answer = c
            break
        # 현재 좌표는 방문한 곳이니 True 설정
        v[x][y] = True
        for dx, dy in direct:
            # 일단 인덱스 안 넘기도록 설정
            if (0 <= (x+dx) < N) and (0 <= (y+dy) < N):
                # 이동하려는 곳이 방문한 곳이면 넘기자
                if v[x+dx][y+dy]: continue
                # 조건 2 만족하는지 설정
                if H[x+dx][y+dy] <= H[x][y]:
                    # 다음 좌표로 이동
                    Q.append((x+dx, y+dy, l, c+1, v))
                # 조건 2 만족하지 않아도, 1번의 기회가 있다면
                elif l == 1:
                    # 기회 박탈하고 다음 좌표로 이동
                    Q.append((x+dx, y+dy, l-1, c+1, v))
    print(answer)

#############################################################

# # 3,5번 failed / 특이점으로 visited 설정 안했다면 4,5,6번 timeout
# from collections import deque

# if __name__ == "__main__":
#     N = int(input())
#     H = [list(map(int, input().split())) for _ in range(N)]
#     direct = ((-1, 0), (1, 0), (0, -1), (0, 1)) # 상하좌우
#     limit = 1 # 개구리가 높이 뛸 수 있는 1번의 기회
#     answer = -1 # 정답 저장(bfs로 하면 도착하는 순간이 최소 개수)
#     count = 1 # 이동한 칸 수 저장(자기 집도 포함인듯?)
#     visited = [[False] * N for _ in range(N)] # 방문칸은 방문하지 마라~

#     Q = deque()
#     Q.append((0,0, limit, count)) # 자기 집 (1,1)이 인덱스로는 (0,0)이다.
#     while Q:
#         x, y, l, c = Q.popleft()
#         # 친구집 도착하면 이동 칸수 저장 하고 반복문 탈출
#         if (x, y) == (N-1, N-1):
#             answer = c
#             break
#         # 이미 방문했던 지역이라면 넘기기
#         if visited[x][y] == True: continue
#         visited[x][y] = True # 아니면 True 설정하고 다음 좌표 찾기
#         for dx, dy in direct:
#             # 일단 인덱스 안 넘기도록 설정
#             if (0 <= (x+dx) < N) and (0 <= (y+dy) < N):
#                 # 조건 2 만족하는지 설정
#                 if H[x+dx][y+dy] <= H[x][y]:
#                     # 다음 좌표로 이동
#                     Q.append((x+dx, y+dy, l, c+1))
#                 # 조건 2 만족하지 않아도, 1번의 기회가 있다면
#                 elif l == 1:
#                     # 기회 박탈하고 다음 좌표로 이동
#                     Q.append((x+dx, y+dy, l-1, c+1))
#     print(answer)