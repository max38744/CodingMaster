'''
토끼와 거북이는 수천년째 달리기 시합을 하고 있습니다.
어느덧 시간이 흘러 21세기가 되었고,
토끼와 거북이의 달리기를 학습한 인공지능 모델이 등장했습니다.
두 가상 동물은 2차원 메타버스 세계에서 달리기 시합을 하게 되었습니다.

달리기 시합의 승자는 미로의 맨 위 왼쪽 칸(1행 1열)에서 출발해 미로의 맨 아래 오른쪽 칸(N행 M열)에 먼저 도착하는 쪽입니다.
미로의 각 칸은 벽 또는 빈 칸으로, 토끼와 거북이 모두 벽을 넘거나 부술 수 없습니다.
미로의 테두리(1행의 위, N행의 아래, 1열의 왼쪽, M열의 오른쪽)는 모두 벽으로 막혀 있습니다.

토끼는 1분에 한 번 상하좌우 중 한 방향으로 최대 2칸 이동합니다.

토끼의 이동을 조금 더 자세하게 서술하겠습니다.
우선 이동할 방향을 정하고, 1칸 이동합니다.
같은 방향으로 1칸 더 이동할 수 있다면 반드시 이동해야 하며, 아니라면 거기서 멈춥니다.
첫 번째 예시 입력을 예로 들면,
토끼 로봇이 오른쪽 - 아래 - 오른쪽 순으로 이동할 때 그의 위치는 1행 1열 - 1행 2열 - 3행 2열 - 3행 4열 순입니다.

미로의 모습이 입력으로 주어집니다. 
토끼가 미로의 맨 위 왼쪽 칸에서 출발해 미로의 맨 아래 오른쪽 칸으로 이동하는데 적어도 몇 분이 걸리는지 출력하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫째 줄에 미로의 세로 너비 N과 가로 너비 M이 주어집니다. (2 ≤ N ≤ 50, 2 ≤ M ≤ 50)

둘째 줄부터 N개의 줄에 걸쳐 미로의 정보가 주어집니다.
#는 벽을 나타내며, .는 빈 칸을 나타냅니다.』

[출력값 설명]
『토끼가 미로의 맨 위 왼쪽 칸에서 출발해 미로의 맨 아래 오른쪽 칸으로 이동하는데 몇 분이 걸리는지 출력합니다.

어떻게 이동해도 맨 아래 오른쪽 칸에 도달하지 못한다면 대신 -1을 출력합니다.』
------------------------------------------------------------------------
예제 입력1
3 4
..##
#.##
....

예제 출력1
3

예제 입력2
5 4
....
#.##
..#.
....
..#.

예제 출력2
-1
'''
# -*- coding: utf-8 -*-
import sys
input=sys.stdin.readline
from collections import deque

def is_poss(y, x):
    return ((0<= y <N) and (0<= x <M) and (maze[y][x] == '.'))

if __name__ == "__main__":
    N, M = map(int, input().split())
    maze = list(list(input().rstrip()) for _ in range(N))
    direct = ((-1, 0), (1, 0), (0, -1), (0, 1)) # 상하좌우
    visited = [[False] * M for _ in range(N)]
    answer = -1
    
    Q = deque()
    Q.append((0,0, 0))
    while Q:
        y, x, cnt = Q.popleft()
        if (y, x) == (N-1, M-1):
            answer = cnt
            break
        if visited[y][x]: continue
        visited[y][x] = True
        for dy, dx in direct:
            # 한 칸 갈 수 있는지 체크
            if is_poss(y+dy, x+dx):
                # 한 칸 더 갈 수 있는지 체크
                if is_poss(y+(dy*2), x+(dx*2)):
                    # 2칸 갈 수 있으면 2칸 간걸로 append
                    Q.append((y+(dy*2), x+(dx*2), cnt+1))
                # 아니면 한 칸 간 걸로만 append
                else: Q.append((y+dy, x+dx, cnt+1))
    print(answer)
