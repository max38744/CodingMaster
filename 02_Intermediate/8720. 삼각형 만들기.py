'''
철수는 집에서 조카를 돌봐주고 있습니다.
조카는 N개의 막대를 가지고 놀고있습니다.
각 막대에는 1번부터 N번까지 번호가 붙어있습니다.
i번 막대의 길이는 a_i로 표기됩니다.

조카는 임의의 막대 세 개를 사용해 삼각형을 만드는데,
어떤 경우에는 삼각형이 제대로 만들어지지만 막대들의 길이에 따라 삼각형이 만들어지지 않는 경우도 존재합니다.
이는 가장 긴 변의 길이가 다른 두 변의 길이의 합보다 작아야 삼각형을 만들 수 있다는 조건 때문입니다.

철수는 조카가 어떤 세 막대를 선택해도 삼각형을 만들 수 있도록 0개 이상의 막대를 버리려고 합니다.

예를 들어 N = 5, 각 막대의 길이가 1, 3, 2, 4, 3이라고 가정하겠습니다.
조카가 1번, 2번, 4번 막대를 선택할 경우, a_1 + a_2 = a_4가 되어 삼각형을 만들 수 없습니다.
1번 막대를 버리고 나면, 2번 ~ 4번 막대 중 어떤 세 막대를 선택해도 삼각형을 만들 수 있습니다.

철수는 가능한 많은 막대를 남기고 싶습니다. 
철수가 남길 수 있는 막대의 최대 개수를 구하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫째 줄에 막대의 개수 N이 주어집니다. (3 ≤ N ≤ 100)
둘째 줄에 i번 막대의 길이 a_i가 공백으로 구분되어 주어집니다. a_i는 정수입니다. (1 ≤ a_i ≤ 1,000,000)
반드시 1개 이상의 삼각형을 만들 수 있는 입력만 주어집니다.』

[출력값 설명]
『첫째 줄에 남길 수 있는 막대의 최대 개수를 출력합니다.』
------------------------------------------------------------------------
예제 입력1
5
1 3 2 4 3

예제 출력1
4

예제 입력2
3
4 2 5

예제 출력2
3
'''
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline

# chk 막대부터 삼각 조건 만족하는 막대 수 반환 함수
def check_tri(chk):
    # 짧은거 2개를 각각 s1, s2에 저장
    s1, s2 = a[chk], a[chk+1]
    # s1, s2 는 남길 막대라 가정하고 진행
    result = 2

    # 길이가 긴걸 체크하려면 N번째까지 체크해야함
    for i in range(chk+2, N):
        # 삼각 조건 만족 시 a[i] 도 남기는걸로 추가
        if (s1 + s2) > a[i]: result += 1
        else: break
    return result

if __name__ == '__main__':
    N = int(input())
    a = list(map(int, input().split()))
    a.sort()
    answer = 3

    for i in range(N-2):
        # i부터 삼각 조건 만족 막대까지 체크하고 그 수를 반환
        answer = max(answer, check_tri(i))
    print(answer)

##################################################################

# # 3~7 전부 안됨...

# # 긴 것 중 조건 만족 못하는거 쳐내는거
# def check_from_here(chk):
#     # chk 이전은 False(버릴 것), chk 이후는 True(남길 것)
#     result = 3
#     r = -1
#     # 커널 필터 씌우듯 해서 찾아보자 (i, i+1, i+2 비교하기)
#     for i in range(chk, N-2):
#         # 삼각 조건 만족을 하면 삼각 가능 수 하나 늘어남!
#         if (a[i]+a[i+1] > a[i+2]): result += 1
#         # 삼각 조건 만족을 안 하면
#         if (a[i]+a[i+1] <= a[i+2]):
#             r = i+2 # 다음부턴 이 r부터 체크하게 해준다.
#             break
#     # for 문 안에서 r 값이 반환 안되면 모든 막대를 다 체크한거임
#     if r == -1: r = N # 마지막을 알려줄 N을 반환해주자

#     # 현재 그룹에서 만족하는 막대 수, 다음 체크할 배열의 인덱스
#     return result, r

# if __name__ == '__main__':
#     N = int(input())
#     a = list(map(int, input().split()))
#     a.sort()
#     answer = 3
#     now_need_to_check_after_here = 1

#     # 우선 짧은 것 중 조건 만족 못 하는 것들 쳐내기
#     for i in range(3, N):
#         # 삼각 조건 만족 시 당시 값 저장 후 break
#         if (a[i-2] + a[i-1] > a[i]):
#             # i-2 부터 3개 체크해봤자 현재 만족하는거 확인함
#             # 고로 i+1 을 체크하려면 i-1, i, i+1 을 체크해야하니까 i-1을 반환해주자
#             now_need_to_check_after_here = i-1
#             break
#     while now_need_to_check_after_here != N:
#         result, now_need_to_check_after_here = check_from_here(now_need_to_check_after_here)
#         answer = max(answer, result)
#     print(answer)