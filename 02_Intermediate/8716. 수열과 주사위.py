'''
어느 날 기승이 종이 한장과 주사위 3개를 가져와 기성에게 게임을 제안했습니다.
주사위는 우리가 일반적으로 알고있는 각 면에 1 이상 6 이하의 서로 다른 정수가 적힌 정육면체입니다.
주사위를 굴리면 1 이상 6 이하의 정수를 각각 1/6의 동일한 확률로 얻을 수 있습니다.
종이에는 N개의 수가 일렬로 적혀있으며, 모든 수는 -100 이상 100 이하의 정수입니다.

기성은 정수 K를 하나 고른 뒤 주사위 3개를 굴립니다.
세 주사위의 눈의 합을 T라고 할 때, 기성의 점수는 종이에 K + T번째로 적힌 수와 같습니다.
만약 K + T가 N보다 크다면 기성의 점수는 -100점입니다.
(단, K의 범위는 1 ≤ K ≤ N 입니다.)

기승도 위와 똑같은 시행을 하여 점수가 높은 사람이 게임에서 이깁니다.
승부욕이 발동한 기성은 어떤 K를 골라야 점수의 기댓값이 최대가 되는지 구하려고 합니다.

기성을 위해 어떤 K를 골라야 점수의 기댓값이 최대가 되는지 출력하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫째 줄에 N이 주어집니다. (1 ≤ N ≤ 10,000)
둘째 줄에 종이에 적힌 N개의 정수가 공백으로 구분되어 주어집니다. (-100 ≤ 종이에 적힌 수 ≤ 100)
i번째 수는 종이에 i번째로 적힌 수와 같습니다.』

[출력값 설명]
『첫째 줄에 점수의 최대 기댓값에 216을 곱해 출력합니다.
기댓값에 216을 곱하면 정수가 됨을 증명할 수 있습니다.
둘째 줄에 점수의 최대 기댓값을 얻기 위해 고를 수 있는 K를 오름차순으로 모두 출력합니다.』
------------------------------------------------------------------------
예제 입력1
20
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

예제 출력1
216
1 2

예제 입력2
25
48 3 39 8 98 38 5 9 83 89 4 8 9 3 9 48 90 88 100 76 5 50 77 23 67

예제 출력2
12345
8
'''
# 주사위 눈의 수 합을 각각의 확률로 작성하면 다음과 같다.
# 합이 3 인 경우의 수(확률) : 1 (1/216)
# 합이 4 인 경우의 수(확률) : 3 (3/216)
# 합이 5 인 경우의 수(확률) : 6 (6/216)
# 합이 6 인 경우의 수(확률) : 10 (10/216)
# 합이 7 인 경우의 수(확률) : 15 (15/216)
# 합이 8 인 경우의 수(확률) : 21 (21/216)
# 합이 9 인 경우의 수(확률) : 25 (25/216)
# 합이 10 인 경우의 수(확률) : 27 (27/216)
# 합이 11 인 경우의 수(확률) : 27 (27/216)
# 합이 12 인 경우의 수(확률) : 25 (25/216)
# 합이 13 인 경우의 수(확률) : 21 (21/216)
# 합이 14 인 경우의 수(확률) : 15 (15/216)
# 합이 15 인 경우의 수(확률) : 10 (10/216)
# 합이 16 인 경우의 수(확률) : 6 (6/216)
# 합이 17 인 경우의 수(확률) : 3 (3/216)
# 합이 18 인 경우의 수(확률) : 1 (1/216)
    
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline

if __name__ == "__main__":
    N = int(input())
    score = list(map(int, input().split()))
    # 주사위 합이 3일 때부터 18일 때까지 경우의 수 (어차피 나중에 216 곱하니 확률로 안 함)
    prob = (1, 3, 6, 10, 15, 21, 25, 27, 27, 25, 21, 15, 10, 6, 3, 1)
    
    # 최대 기댓값 넣을 expected (최저 값이 -21600 이니까 -21601 로 초기값 설정)
    expected = -21601
    answer = []
    
    # K의 범위 체크
    for K in range(1, N+1):
        s, e = K + 2, K + 18 # 인덱스 넘버는 0부터 시작이라 1씩 빼준다.
        # 현재 나올 수 있는 모든 점수
        now_score_lst = score[s:e]
        for _ in range(N, e):
            now_score_lst.append(-100)
        
        # 각각의 점수에 확률 값을 곱한다.
        ex = 0
        for i in range(16):
            ex += prob[i] * now_score_lst[i]
        
        # 계산해서 나온 기댓값이 이전에도 나온 적 있는 값이라면 K 값 저장
        if ex == expected: answer.append(K)
        # 현재 계산한 기댓값이 최댓값이면 초기화해주고 현재 K 값 저장
        elif ex > expected:
            expected = ex
            answer = [K]
    print(expected)
    print(*answer)