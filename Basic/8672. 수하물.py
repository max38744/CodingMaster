'''
민주는 미국으로 1년 동안 유학을 가게 되었습니다.
출국까지 일주일 남은 시점에서 민주는 큰 고민에 빠졌습니다.
아끼는 물건들을 모두 가져가고 싶기 때문입니다.

민주가 가져가고 싶은 물건들의 무게와 가격들이 주어집니다.
민주는 가방을 K개 갖고 있고, 하나의 가방에는 해당 가방의 무게 제한을 넘지 않는 물건 단 하나만 담을 수 있습니다.

물건과 가방의 정보가 주어질 때,
민주가 가져갈 수 있는 물건들의 가격의 합의 최댓값을 구하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫째 줄에 민주가 가져가고 싶은 물건의 개수 N과 가방의 수 K가 각각 양의 정수로 주어집니다. (1 ≤ N ≤ 500) (1 ≤ K ≤ 500)
다음 N개 줄에는 각 물건의 무게 M과 가격 V가 각각 양의 정수로 주어집니다. (1 ≤ M ≤ 500) (0 ≤ V ≤ 500)
다음 K개 줄에는 각 가방에 담을 수 있는 무게 제한 C가 양의 정수로 주어집니다. (1 ≤ C ≤ 10,000)』

[출력값 설명]
『첫째 줄에 정답을 출력합니다.』
------------------------------------------------------------------------
예제 입력1
14 7
402 423
274 318
230 241
393 495
443 449
212 410
479 500
259 434
90 229
116 325
361 387
62 88
285 459
221 435
6443
8308
7310
1017
2419
5923
6482

예제 출력1
3195

예제 입력2
23 14
79 261
22 461
470 481
315 353
193 469
390 443
195 355
362 368
416 459
444 497
499 500
398 467
353 394
417 424
225 414
16 482
365 388
475 498
22 252
322 451
384 477
117 416
241 251
794
9078
4966
2960
1477
2167
6352
9806
6875
3587
8093
1703
8931
9492

예제 출력2
6525
'''
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline

if __name__ == "__main__":
    # 물건 개수 N, 가방 수 K (1 ≤ N ≤ 500) (1 ≤ K ≤ 500)
    N, K = map(int, input().split())
    # 물건들의 무게 M, 가격 V (1 ≤ M ≤ 500) (0 ≤ V ≤ 500)
    objs = list(tuple(map(int, input().split())) for _ in range(N))
    # 각 가방의 무게제한 C (1 ≤ C ≤ 10,000)
    bags = list(int(input()) for _ in range(K))
    
    # 물건들을 가격순으로 정렬해서, pop으로 마지막부터 꺼내서 확인해보자
    objs.sort(key=lambda x: x[1])
    # 가방은 무게 제한이 가장 작은 것부터 채워넣는다 생각하고 정렬
    bags.sort()
    
    # 사용한 가방인지 체크하기 위한 배열
    used_bag = [False] * K
    
    answer = 0
    # 아직 안 담은 가방이 있으면 계속 체크 and 물건이 남아있어야 함
    while (False in used_bag) and objs:
        # 현재 안 담은 물건 중 가장 비싼거 먼저 체크
        M, V = objs.pop()
        # 가장 무게 제한 작은 가방부터 체크해보자
        for i, C in enumerate(bags):
            # 체크 중인 가방이 사용 안했고, 물건 담는게 가능하다면,
            if (not used_bag[i]) and (M < C):
                # 현재 가방에 담아준다
                used_bag[i] = True
                # 그리고 전체 가치(answer)에 더해주자
                answer += V
                # 일련의 작업이 끝났으니 for문은 빠져나오기
                break
    print(answer)

# # 7번 타임아웃 -> 가방에 다 못 담는 경우가 있을수도?
# if __name__ == "__main__":
#     # 물건 개수 N, 가방 수 K (1 ≤ N ≤ 500) (1 ≤ K ≤ 500)
#     N, K = map(int, input().split())
#     # 물건들의 무게 M, 가격 V (1 ≤ M ≤ 500) (0 ≤ V ≤ 500)
#     objs = list(tuple(map(int, input().split())) for _ in range(N))
#     # 각 가방의 무게제한 C (1 ≤ C ≤ 10,000)
#     bags = list(int(input()) for _ in range(K))
    
#     # 물건들은 비싼 것부터 챙길거니까 가격이 비싼 순으로 정렬
#     objs.sort(key=lambda x: x[1], reverse=True)
#     # 가방은 무게 제한이 가장 작은 것부터 채워넣는다 생각하고 정렬
#     bags.sort()
    
#     # 이미 담은 물건인지 체크하기 위한 배열
#     already_obj = [False] * N
#     # 사용한 가방인지 체크하기 위한 배열
#     used_bag = [False] * K
    
#     answer = 0
#     # 아직 안 담은 가방이 있으면 계속 체크
#     while (False in used_bag):
#         # 물건 먼저 확인 (이미 비싼 것부터 순차 체크하도록 함)
#         for i, obj in enumerate(objs):
#             # 만약 아직 안 담은 물건이라면
#             if already_obj[i] == False:
#                 # 무게랑 가격 따로 확인하자
#                 M, V = obj
#                 # 이제 가방을 확인할 차례
#                 for j, bag in enumerate(bags):
#                     # 아직 사용 안 한 가방이면서, 물건이 가방에 들어가면
#                     if (used_bag[j] == False) and (M < bag):
#                         # 이제 사용한 물건, 가방이라고 체크해주고
#                         already_obj[i] = True
#                         used_bag[j] = True
#                         # 답에 가격을 더해주자
#                         answer += V
#                         break
#     print(answer)