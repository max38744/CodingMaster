'''
신입사원 종구는 달고나를 너무 좋아해서 매일 엄청난 양의 달고나를 먹습니다.
결국 종구는 참지 못하고 직접 달고나를 해먹고자 달고나 판을 구매했습니다.
종구가 구매한 달고나 판은 다양한 크기의 구멍이 여러개 있습니다.

달고나를 만들 때는 판 전체에 설탕물을 부어야 하고,
달고나 판의 특성상 두 구멍이 상하좌우로 붙어있으면 하나의 달고나로 합쳐집니다.

달고나 판의 구멍들의 위치가 주어지면,
달고나를 한 번 만들 때 몇 개의 달고나가 만들어지는지 출력하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫 번째 줄에 달고나 판의 세로 길이 N과 가로 길이 M이 주어집니다. (1 ≤ N, M ≤ 100)
두 번째 줄부터 N+1번째 줄까지 0과 1로 달고나 판의 형태가 주어집니다. 구멍이 뚫린 곳은 0, 막혀있는 곳은 1입니다.』

[출력값 설명]
『달고나를 한 번 만들 때 몇 개의 달고나가 만들어지는지 출력합니다.』
------------------------------------------------------------------------
예제 입력1
2 3
010
101

예제 출력1
3

예제 입력2
5 5
00100
00100
11111
00100
00100

예제 출력2
4
'''
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline
from collections import deque

# 현재 들어온 좌표랑 연결되는 칸들 전부 찾기
def chk_area(board, y, x):
    direct = ((-1, 0), (1, 0), (0, -1), (0, 1)) # 상하좌우
    # BFS 탐색을 위해 Q를 먼저 만들고 넣어주자
    Q = deque()
    Q.append((y, x))
    # BFS 탐색 시작
    while Q:
        # 일단 Q에 있던 값은 무조건 방문 처리 (1)
        y, x = Q.popleft()
        board[y][x] = 1
        # 상하좌우 탐색하면서
        for dy, dx in direct:
            # 파이썬은 -1도 리스트 값으로 인식되므로 그런 경우 방지할 범위 우선 설정
            if (0 <= y+dy < N) and (0 <= x+dx < M):
                # 1이 아닌 곳이라면, Q에 집어넣자
                if board[y+dy][x+dx] != 1: Q.append((y+dy, x+dx))
    # 반환은 방문처리 전부 완료된 board를 반환    
    return board

if __name__ == "__main__":
    N, M = map(int, input().split())
    board = list(list(map(int, list(input().rstrip()))) for _ in range(N))
    
    # 몇 개의 영역이 나오는지 저장할 answer
    answer = 0
    # (0, 0)부터 체크해 나가면서
    for y in range(N):
        for x in range(M):
            # 만약 빈 공간이라면
            if (board[y][x] == 0):
                # 빈 공간에 연결된 칸들을 전부 하나의 묶음으로 처리하자
                board = chk_area(board, y, x)
                # 공간 하나 찾았으니깐 +1
                answer += 1
    print(answer)